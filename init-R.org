#+TITLE: Configuration for R project as well as for general programming commands

Enable tooltips for R objects, hints to function arguments and debugging.
#+BEGIN_SRC emacs-lisp
  (require 'ess-r-args)
  (require 'ess-R-object-tooltip)
#+END_SRC

** Ess-tracebug:
Enable ess-tracebug:

#+BEGIN_SRC emacs-lisp
  (setq ess-tracebug-prefix "\M-c")   ; define debug-mode starting key
  (setq ess-use-tracebug t)
  (setq ess-tracebug-inject-source-p t)
  ;; (add-hook 'ess-post-run-hook 'ess-tracebug) ; activate ess-tracebug every time R session starts
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (defun r-debug-narrowed-region ()
     "Debug narrowed region or current block remotely. Region must load previous
  workspace if require."
     (interactive)
     (let ((fileName buffer-file-name)   ; store current file name
             (processName ess-local-process-name)       ; store current process name
             )
        
        ;; (goto-char (point-min))
        (backward-block)
        (push-mark)
        ;; (forward-block)
        (goto-char (point-max))
  
        (kill-ring-save (point) (mark))                     ; copy region
  
  
        (if (get-buffer "tmp_debug_file.r")     ; if temp buffer already exists, kill it
           (kill-buffer "tmp_debug_file.r")
           )
        (switch-to-buffer "tmp_debug_file.r")
  
        (yank)                               ; yank copied text
        (write-file (concat (file-name-directory fileName) "tmp_debug_file.r")) ; save modified file in same directory
        (ess-force-buffer-current " " processName) ; attach same process to tmp_debug_file
                                          ; ess-local-process-name
        (switch-to-buffer "tmp_debug_file.r")
        (ess-tracebug 1)                        ; Enable ess-tracebug
        ;; (ess-tracebug-source-current-file)
        )
     )
  
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (defun cg/r-debug-org-edit-src-code ()
     "Debug currently edited source code block of org-babel file."
     (interactive)
     (let ((fileName buffer-file-name)   ; store current file name
             (buffName (buffer-name))
             (processName ess-local-process-name)       ; store current process name
             )
  
        ;; if temp buffer already exists, kill it
        (if (get-buffer "tmp_debug_file.r") 
           (kill-buffer "tmp_debug_file.r")
           )
        
        (delete-file (concat (file-name-directory fileName) "tmp_debug_file.r")) ; delete old version of file
        
        (goto-char (point-min))
        (push-mark)
        (goto-char (point-max))
        
        (kill-ring-save (point) (mark))                    ; copy region
        
        (switch-to-buffer "tmp_debug_file.r")
  
        (yank)                              ; yank copied text
        (write-file (concat (file-name-directory fileName) "tmp_debug_file.r")) ; save modified file in same directory
        (ess-force-buffer-current " " processName) ; attach same process to tmp_debug_file
                                          ; ess-local-process-name
        ;; (switch-to-buffer buffName)
        ;; (setq buffer-file-name (concat (file-name-directory fileName) "tmp_debug_file.r"))
        ;; (kill-buffer "tmp_debug_file.r")
        (ess-tracebug 1)                       ; Enable ess-tracebug
        ;; (ess-tracebug-source-current-file)
        )
     )
#+END_SRC

#+BEGIN_SRC emacs-lisp

#+END_SRC

(defun r-select-superior ()
  "Select superior word encompassing point."
  (interactive)
  (search-backward-regexp "[^a-zA-Z0-9_$.]") ; go back to first char not part of word
  (forward-char)			     
  (push-mark)				; push mark
  (search-forward-regexp "[^a-zA-Z0-9_]") ; go forth to first char not part in superior word
  (backward-char)
  (copy-region-as-kill (point) (mark))	; copy region
  )

(define-key ess-mode-map (kbd "C-c C-<SPC>") 'r-select-superior)

(defun r-select-inferior ()
  "Select superior word encompassing point."
  (interactive)
  (search-backward-regexp "[^a-zA-Z0-9_$.]") ; go back to first char not part of word
  (forward-char)			     
  (push-mark)				; push mark
  (search-forward-regexp "[^a-zA-Z0-9_$.]") ; go forth to first char not part in superior word
  (backward-char)
  (copy-region-as-kill (point) (mark))	; copy region
  )

(define-key ess-mode-map (kbd "C-c <SPC>") 'r-select-inferior)

(defun r-show-head ()
  (interactive)
  (save-excursion
    (ess-request-a-process ess-local-process-name)
    (insert "head(")
    (yank)
    (insert ")")
    (inferior-ess-send-input)
    (end-of-buffer)
    (recenter -1)
    )
  )

(define-key ess-mode-map (kbd "C-c 1") 'r-show-head)

(defun r-show-str ()
  (interactive)
  (save-excursion
    (ess-request-a-process ess-local-process-name)
    (insert "str(")
    (yank)
    (insert ")")
    (inferior-ess-send-input)
    (end-of-buffer)
    (recenter -1)
    )
  )
(define-key ess-mode-map (kbd "C-c 2") 'r-show-str)



* underscore properties
#+BEGIN_SRC emacs-lisp
  (defun cg/R-assign ()
     "Insert assignment sign of R language"
     (interactive)
     (insert " <- "))
  
  (define-key ess-mode-map (kbd "M--") 'cg/R-assign)
  (define-key ess-mode-map (kbd "_") 'self-insert-command)
#+END_SRC

* enable evaluation of syntactic units

** enable evaluation of connected regions without empty lines

(defun ess-eval-sentence ()
  "Eval sentence: regions without empty lines."
  (interactive)
  (forward-sentence)
  (backward-sentence)
  (push-mark)
  (forward-sentence)
  (ess-eval-region (point) (mark) t)
  )

(define-key ess-mode-map (kbd "C-c M-e") 'ess-eval-sentence)
