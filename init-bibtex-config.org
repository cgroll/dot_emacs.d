TITLE: Bibtex settings

* Create entry

- C-c C-b: bibtex-entry
- direct command: C-c C-e C-a: article

* Motion
- jump to beginning / end of entry:
  - M-C-a (bibtex-beginning-of-entry)
  - M-C-e
- move to right end of field: TAB (bibtex-find-text)
- jump to next field: bibtex-next-field
- reposition window: M-C-l -> DOES NOT WORK ON UBUNTU: log out from
  system 

* Entry manipulation
- bibtex-remove-delimiters
- bibtex-remove-OPT-or-ALT
- bibtex-clean-entry C-c C-c
- bibtex-empty-field C-c C-d
- bibtex-make-field C-c C-f
- bibtex-kill-field C-c C-k
- bibtex-yank C-c C-y
- bibtex-copy-field-as-kill C-c M-k (copy field, includes field name)
- bibtex-fill-entry align entry: C-c C-q

* Entry format
#+BEGIN_SRC emacs-lisp
  (setq bibtex-align-at-equal-sign nil)
  (setq bibtex-field-delimiters 'braces) 
  (setq bibtex-comma-after-last-field t)
  (setq bibtex-maintain-sorted-entries t)
#+END_SRC

- (setq bibtex-align-at-equal-sign nil) do not align equal signs also
- (setq bibtex-field-delimiters 'braces) 
- (setq bibtex-comma-after-last-field t)
- (setq bibtex-maintain-sorted-entries t) -> buffer local
- check syntax with bibtex-validate

* Entry cleansing
#+BEGIN_SRC emacs-lisp
  (setq bibtex-entry-format '(opts-or-alts required-fields
                                numerical-fields realign last-comma
                                delimiters unify-case))
  
#+END_SRC

- bibtex-clean-entry: check if any required fields are missing -> C-c
  C-c
- bibtex-entry-format:
  - opts-or-alts: t -> delete unnecessary optional fields
  - required-fields: t -> error if required field is missing
  - numerical-fields: t -> remove unnecessary delimiters
  - page-dashes: nil -> would change page dashes to single dash
  - inherit-booktitle: nil -> for cross-references: could complicate
    things unnecessarily
  - realign: t -> automatically realign entry
  - last-comma: t -> include comma for last field: could improve
    adding fields afterward
  - delimiters: t -> change to specified delimiter option
  - unify-case: t -> automatically adapt uppercase / lowercase
    letters to standard


* Reference key generation

#+BEGIN_SRC emacs-lisp  
  (defun cg/check-file-name (proposed_name)
     "function shall guarantee valid file names for unix OS"
     (interactive)
     (setq return-string (replace-regexp-in-string "[^A-Za-z0-9_+-]" "" proposed_name))
     return-string
     )
  
  (setq bibtex-autokey-before-presentation-function 'cg/check-file-name)
  (add-hook 'bibtex-autokey-before-presentation-hook 'cg/check-file-name)
  (setq bibtex-autokey-edit-before-use t)
  (setq bibtex-autokey-prefix-string "")
  
  (require 'bibtex)
  ;; (add-to-list 'bibtex-autokey-name-change-strings
  ;;    '("\(Mittnik\)" . "Mitt"))
  ;; (add-to-list 'bibtex-autokey-name-change-strings
  ;;    '("Engle" . "Eng"))
  ;; (add-to-list 'bibtex-autokey-name-change-strings
  ;;    '("\(TerÃ¤svirta\)" . "Tera"))
  
  ;; author name properties
  (setq bibtex-autokey-names 2)
  (setq bibtex-autokey-name-length 4)
  (setq bibtex-autokey-name-separator "_")
  (setq bibtex-autokey-additional-names "")
  (setq bibtex-autokey-year-length 4)
  (setq bibtex-autokey-year-use-crossref-entry nil)
  
  ;; title properties
  (setq bibtex-autokey-titlewords 4)
  (setq bibtex-autokey-titleword-change-strings nil)    
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("Copulas" . "cop"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("copula" . "cop"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("extreme value theory" . "evt"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("\([Ff]inancial\)" . "fin"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("econometrics" . "econ"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("\\(GARCH\\)" . "gch"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("ARCH" . "ach"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("[Ii]ntroduction" . "intr"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("univariate" . "univ"))
  ;; (add-to-list 'bibtex-autokey-titleword-change-strings
  ;;    '("multivariate" . "mvar"))
  
  (setq bibtex-autokey-titleword-length "20")
  
  ;; separators
  (setq bibtex-autokey-titleword-separator "_")
  (setq bibtex-autokey-name-year-separator "_")
  (setq bibtex-autokey-year-title-separator "_")
  
#+END_SRC
- use bibtex-autokey-before-presentation-hook to include a check so
  that key can be used as file name
- set bibtex-autokey-before-presentation-hook to cg/check-file-name
- (setq bibtex-autokey-edit-before-use nil) -> do not prompt for key
  confirmation
- constant prefix: rv -> "revised"
- (setq bibtex-autokey-prefix-string "rv")
- name part:
  - bibtex-autokey-name-change-strings -> leave unchanged
  - (setq bibtex-autokey-names 2) -> two authors shall be named
  - (setq bibtex-autokey-name-length 4)
  - (setq bibtex-autokey-name-separator "_")
  - (setq bibtex-autokey-additional-names "")
- year part:
  - (setq bibtex-autokey-year-length 4)
  - (setq bibtex-autokey-year-use-crossref-entry nil)
- title part:
  - 

* Place mark
- bibtex-mark-entry: place mark at beginning, put point at end of entry

* Get help to fields
- bibtex-help-message C-c ?


bibtex-entry-field-alist
* Implement adding to library
#+BEGIN_SRC emacs-lisp
  ;; multiple functions
  ;; cg/get-bibtex-to-processing-buffer
  ;; cg/clean-up-bib-info-entry
  ;; cg/create-org-mode-entry
  
  (defun cg/bib_capturing ()
     "capture bibtex entry of an type and link and rename associated pdf
  or specify string for location"
     (interactive)
     
     
     (let
        (
           ;; set variables for paths
           (lit_dir  "~/Dropbox/literature")
           (rv_file_bib 
              "~/Dropbox/literature/management/bib_process_file.bib")
           (rv_file_org 
              "~/Dropbox/literature/management/bib_process_file.org")
           (bib_tex_file 
              "~/Dropbox/literature/management/refs_test.bib")
           
           
           ;; set variables
           bib-key
           short-bib-key
           clean_bibtex_entry
           old_file_name
           new_file_name
           )
        
        ;; prompt for bibtex input, copy and jump to working file
        (cg/get-bibtex-to-processing-buffer rv_file_bib)
        
        ;; clean up entry, get clean key, ask for content location
        (beginning-of-buffer)
        (bibtex-mode)
        (bibtex-beginning-of-entry)
        (bibtex-clean-entry t)            ; error could be thrown at
                                          ; this point!!
        (beginning-of-buffer)
        (bibtex-beginning-of-entry)      
        (bibtex-find-text)
        (let (beg_point end_point)
           (setq end_point (point))
           (search-backward "{")
           (forward-char)
           (setq beg_point (point))
           (setq bib-key (buffer-substring beg_point end_point))
           )
  
        
        (message bib-key)
  
        (beginning-of-buffer)
        (insert "\n")      
        (end-of-buffer)
        (insert "\n")      
        
        ;; bibtex entry is finished and ready for copying
        (setq clean_bibtex_entry (buffer-string))
  
        ;; clear .org file before capturing new entry
        (find-file rv_file_org)
        (delete-region (point-min) (point-max))
        (switch-to-buffer "bib_process_file.bib")
        (beginning-of-buffer)
        (search-forward "@")
        (bibtex-beginning-of-entry)
        
        ;; ask, if file shall be included
        (if (yes-or-no-p "Shall local file be included? ")
           (progn
              ;; (setq short-bib-key (substring bib-key 3))
              (setq new_file_name
                 (cg/prompt-for-file-and-return-bibtex-key-file-name-with-extension
                    bib-key))
              (org-capture nil "BW")
              )
           (org-capture nil "BZ")
           
           )
        (org-capture-finalize)
  
        ;; copy to one processing buffer
        (switch-to-buffer "bib_process_file.org")
        (setq clean_org_entry (buffer-string))
        (switch-to-buffer "bib_process_file.bib")
  
        ;; add rv_ to bibtex-key
        (beginning-of-buffer)
        (search-forward "@")
        (search-forward "{")
        (insert "rv_")
  
        ;; insert org entry
        (end-of-buffer)
        (insert clean_org_entry)
        
        ;; if everything is correct, copy entries, else edit
        (if (yes-or-no-p "Shall bibtex entry be copied?")
           (progn
              (save-excursion
                 (find-file
        "~/Dropbox/literature/management/references.bib")
                 (end-of-buffer)
                 (insert clean_bibtex_entry)
                 (bibtex-sort-buffer)
                 (save-buffer)
                 (switch-to-buffer "bib_process_file.bib")
                 )
              )
           )
        
           ;; copy bibtex entry to database and ask for refile
        (if (yes-or-no-p "Shall org entry be refiled now?")
           (progn
              (org-mode)
              (outline-next-heading)
              (org-refile)
              )
           )
        
        )
     )
  
  (global-set-key (kbd "C-5") 'cg/bib_capturing)
  
  (defun cg/prompt-for-file-and-return-bibtex-key-file-name-with-extension
     (key)
     "function shall prompt for file, create clean new name for
     file, move file to literature database, and return org-link to
     file"
     (interactive)
     (let (local-file new-local-file-name return-string)
        (setq local-file (read-file-name
                            "Where is associated document file?"
                            "~/Downloads/" nil 'confirm))
        (if (file-exists-p local-file)
           (progn
              (setq new-local-file-name
                 (concat "~/literature/" key "."
                    (file-name-extension local-file)))
              (rename-file local-file new-local-file-name)
              (setq return-string (concat "[file:" new-local-file-name
                                     "]"))
              )
           (setq return-string (read-string "Where can file be found?"))
           return-string
           )
        )
     )
  
  
  (defun cg/get-bibtex-to-processing-buffer (rv_file_bib)
     "the function asks for literature information input and brings it
     to a file that will be starting point for further proceeding"
     (interactive)
     (let ((mylist (list "emacs-kill-ring" "clipboard" "file"))
             (process-file rv_file_bib)
             bib-info-type bib-info-entry
             )
        
        (setq bib-info-type (ido-completing-read
                               "Where is the bibtex entry? " mylist))
        (cond
           ((string= bib-info-type "file")  ; in case I want to choose a
                                          ; file
              (save-excursion
                 (ido-find-file-other-window) ; copy bibtex text 
                 (setq bib-info-entry (buffer-string))
                 (kill-buffer)
                 )
              (find-file process-file)
              (delete-region (point-min) (point-max))
              (goto-char (point-min))
              (insert bib-info-entry)
              )
           
           ((string= bib-info-type "emacs-kill-ring") ; in case bibtex is
                                          ; given via emacs-kill-ring 
              (setq bib-info-entry (substring-no-properties (car
                                                               kill-ring)))
              (find-file-other-window process-file)
              (delete-region (point-min) (point-max))
              (goto-char (point-min))
              (insert bib-info-entry)
              )
           
           ((string= bib-info-type "clipboard") ; get entry from
                                          ; clipboard
              (find-file-other-window process-file)
              (delete-region (point-min) (point-max))
              (goto-char (point-min))
              (clipboard-yank)
              )
           )
        )
     )
  
  
  
  ;; (defun cg/clean-up-bibtex-entry ()
  ;;    "the function shall clean-up an imported bibtext entry"
  ;;    (interactive)
  ;;    (bibtex-clean-entry t)
  ;;    ;; (let (feedback answer)
  ;;    ;;    (setq feedback (bibtex-clean-entry t))
  ;;    ;;    (setq answer (yes-or-no-p (concat "Proceed with: " feedback)))
  ;;    ;;    (if answer
  ;;    ;;       (message "we will proceed")
  ;;    ;;       )
  ;;    ;;    )
  ;;                                         ;(bibtex-fill-entry) ; should already be included in bibtex-clean-entry
  ;;    )
  
  
  ;; (setq org-capture-templates nil)
  (setq org-capture-templates
     (append org-capture-templates
        (quote (
      ("B" "BIBTEX templates")
                  ("BW" "BIBTEX entry with file"
                     entry
                     (file
                        "~/literature/management/bib_process_file.org")
                     "**** %:title
      :PROPERTIES:
      :type: %:btype
      :author: %:author
      :year: %:year
      :journal: %:journal
      :Bibtex_key: *rv_%:key*
      :link_to_bibtex_entry: [file:~/literature/management/refs_test.bib::rv_%:key]
      :link_to_file: [file:~/literature/%:key.pdf]
      :link_to_notes: [file:~/literature/management/notes/%:key.org]
      :entered: %U
      :END:
      Comment:
      " :empty-lines 1)
                  )
           )
        )
     )
  
  (setq org-capture-templates
     (append org-capture-templates
        (quote (

                  ("BZ" "BIBTEX entry without file"
                     entry
                     (file
                        "~/literature/management/bib_process_file.org")
                     "**** %:title
      :PROPERTIES:
      :type: %:btype
      :author: %:author
      :year: %:year
      :journal: %:journal
      :Bibtex_key: *rv_%:key*
      :link_to_bibtex_entry: [file:~/literature/management/refs_test.bib::rv_%:key]
      :location: %(cg/get-location-from-user-via-prompt)
      :link_to_notes: [file:~/literature/management/notes/%:key.org]
      :entered: %U
      :END:
      Comment:
      " :empty-lines 1)
                  )
           )
        )
     )
  
  (defun cg/get-location-from-user-via-prompt ()
     "prompt user for location description and return string"
     (interactive)
     (let (location)
        (setq location
           (read-from-minibuffer
              "Where can literature entry be found? "))
        location
        )
     )
  
  
  (defun cg/create-new-literature-entry ()
     "switch to bibtex processing file and enter new entry"
     (interactive)
     (find-file "~/literature/management/bib_process_file.bib")
     (delete-region (point-min) (point-max))
     (bibtex-mode)
     )
  
  (global-set-key (kbd "C-6") 'cg/create-new-literature-entry)
#+END_SRC
